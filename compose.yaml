services:
  kafka:
    image: confluentinc/confluent-local:7.4.3
    hostname: kafka
    container_name: kafka
    ports:
      - "9092:9092" # for client connections
      - "9101:9101" # JMX
    restart: unless-stopped
    environment:
      KAFKA_NODE_ID: 1
      KAFKA_ADVERTISED_LISTENERS: 'PLAINTEXT://kafka:29092,PLAINTEXT_HOST://localhost:9092'
      KAFKA_JMX_PORT: 9101
      KAFKA_JMX_HOSTNAME: localhost
      KAFKA_PROCESS_ROLES: 'broker,controller'
      KAFKA_CONTROLLER_QUORUM_VOTERS: '1@kafka:29093'
      KAFKA_LISTENERS: 'PLAINTEXT://kafka:29092,CONTROLLER://kafka:29093,PLAINTEXT_HOST://0.0.0.0:9092'
      CLUSTER_ID: 'K0EA9p0yEe6MkAAAAkKsEg'

  kafka-init-topics:
    image: confluentinc/confluent-local:7.4.3
    container_name: kafka-init-topics
    depends_on:
      - kafka
    command: "bash -c \
                'kafka-topics --create --topic telemetry.sensors.v1 \
                             --partitions 1 --replication-factor 1 --if-not-exists \
                             --bootstrap-server kafka:29092 && \
                kafka-topics --create --topic telemetry.snapshots.v1 \
                             --partitions 1 --replication-factor 1 --if-not-exists \
                             --bootstrap-server kafka:29092 && \
                kafka-topics --create --topic telemetry.hubs.v1 \
                             --partitions 1 --replication-factor 1 --if-not-exists \
                             --bootstrap-server kafka:29092'"
    init: true

  db:
    image: postgres:16.1
    container_name: smart-home-db
    ports:
      - "5432:5432"
#    volumes:
#      - ./telemetry/analyzer/src/main/resources/schema.sql:/docker-entrypoint-initdb.d/schema.sql
    environment:
      - POSTGRES_PASSWORD=12345
      - POSTGRES_USER=dbuser
      - POSTGRES_DB=analyzer
    healthcheck:
      test: pg_isready -q -d $$POSTGRES_DB -U $$POSTGRES_USER
      timeout: 5s
      interval: 5s
      retries: 10

  db-init:
    image: postgres:16.1
    container_name: db-init
    # секция для указания зависимостей от других сервисов
    depends_on:
      # указываем, что этот сервис зависит от сервиса с именем db
      db:
        # указываем, что условием запуска будет момент, когда
        # сервис db будет в «здоровом» состоянии
        condition: service_healthy
    entrypoint:
      - bash
      - -c
      - |
        set -e
        psql postgresql://dbuser:12345@db:5432/analyzer -v ON_ERROR_STOP=1 <<-EOSQL
          CREATE TABLE IF NOT EXISTS scenarios(
            id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
            hub_id VARCHAR,
            name   VARCHAR,
            UNIQUE (hub_id, name)
          );
  
          CREATE TABLE IF NOT EXISTS sensors(
            id VARCHAR PRIMARY KEY,
            hub_id VARCHAR
          );
  
          CREATE TABLE IF NOT EXISTS conditions(
            id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
            sensor_id VARCHAR REFERENCES sensors (id),
            type VARCHAR,
            operation VARCHAR,
            value INTEGER
          );
  
          CREATE TABLE IF NOT EXISTS actions(
            id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
            sensor_id VARCHAR REFERENCES sensors (id),
            type VARCHAR,
            value INTEGER
          );
  
          CREATE TABLE IF NOT EXISTS scenario_conditions(
            scenario_id  BIGINT REFERENCES scenarios (id),
            condition_id BIGINT REFERENCES conditions (id),
            PRIMARY KEY (scenario_id, condition_id)
          );
  
          CREATE TABLE IF NOT EXISTS scenario_actions(
            scenario_id BIGINT REFERENCES scenarios (id),
            action_id BIGINT REFERENCES actions (id),
            PRIMARY KEY (scenario_id, action_id)
          );
  
          CREATE OR REPLACE FUNCTION check_action_hub_id()
          RETURNS TRIGGER AS
          'BEGIN
            IF (SELECT hub_id FROM scenarios
                WHERE id = NEW.scenario_id) != (SELECT s.hub_id FROM actions a, sensors s
                   WHERE a.id = NEW.action_id and s.id = a.sensor_id) THEN
                    RAISE EXCEPTION ''Hub IDs do not match for scenario_id and sensor_id'';
            END IF;
            RETURN NEW;
          END;'
          LANGUAGE plpgsql;
  
          CREATE OR REPLACE FUNCTION check_condition_hub_id()
          RETURNS TRIGGER AS
            'BEGIN
              IF (SELECT hub_id FROM scenarios
                WHERE id = NEW.scenario_id) != (SELECT s.hub_id FROM conditions c, sensors s
                  WHERE c.id = NEW.condition_id and s.id = c.sensor_id) THEN
                    RAISE EXCEPTION ''Hub IDs do not match for scenario_id and sensor_id'';
            END IF;
            RETURN NEW;
          END;'
          LANGUAGE plpgsql;
  
          CREATE OR REPLACE TRIGGER tr_bi_scenario_conditions_hub_id_check
            BEFORE INSERT ON scenario_conditions
              FOR EACH ROW EXECUTE FUNCTION check_condition_hub_id();
  
          CREATE OR REPLACE TRIGGER tr_bi_scenario_actions_hub_id_check
            BEFORE INSERT ON scenario_actions
              FOR EACH ROW EXECUTE FUNCTION check_action_hub_id();
        EOSQL